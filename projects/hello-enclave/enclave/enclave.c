/*
 * enclave.c — Trusted code running inside the SGX enclave
 *
 * KEY RULES:
 * 1. No direct I/O (no printf, no file access, no network)
 * 2. No syscalls — everything goes through OCALLs
 * 3. All memory here is encrypted by the CPU (in simulation, this is mocked)
 * 4. Any data received via OCALLs must be treated as UNTRUSTED
 * 5. Keep enclave code minimal to reduce attack surface
 */

#include "enclave_t.h"  /* Generated by sgx_edger8r from enclave.edl */
#include "sgx_trts.h"
#include "sgx_tseal.h"
#include <string.h>
#include <stdint.h>

/* ============================================================
 * ECALL: ecall_hello
 * Simple demonstration — performs "secret" computation inside
 * the enclave and returns the result.
 * ============================================================ */
sgx_status_t ecall_hello(int *result)
{
    /* We can call out to the untrusted side to print */
    ocall_print("[Enclave] Hello from inside the enclave!");

    /* This computation happens in protected memory.
     * In a real app, this would be crypto operations, key derivation,
     * processing sensitive data, etc. */
    int secret_a = 17;
    int secret_b = 25;
    int computed = secret_a + secret_b;  /* = 42 */

    ocall_print("[Enclave] Secret computation complete.");

    /* Write result to the output buffer (marshaled back to untrusted side) */
    *result = computed;

    return SGX_SUCCESS;
}

/* ============================================================
 * ECALL: ecall_process_buffer
 * Demonstrates processing a data buffer inside the enclave.
 * Here we simply XOR each byte with 0xAA (a trivial "encryption").
 * In practice, you'd use real crypto (AES-GCM, etc.).
 * ============================================================ */
sgx_status_t ecall_process_buffer(const uint8_t *input, size_t len, uint8_t *output)
{
    ocall_print("[Enclave] Processing buffer inside enclave...");

    for (size_t i = 0; i < len; i++) {
        output[i] = input[i] ^ 0xAA;
    }

    ocall_print("[Enclave] Buffer processing complete.");
    return SGX_SUCCESS;
}

/* ============================================================
 * ECALL: ecall_seal_data
 * Sealing = encrypting data with a key derived from the CPU
 * and enclave identity. Only this exact enclave on this CPU
 * can unseal it later. Used for persisting secrets to disk.
 *
 * In simulation mode, the sealing key is deterministic/fake.
 * On real hardware, it's derived from the CPU's fused key.
 * ============================================================ */
sgx_status_t ecall_seal_data(
    const uint8_t *plaintext,
    size_t len,
    uint8_t *sealed_data,
    size_t sealed_len,
    size_t *actual_sealed_len)
{
    /* Calculate required sealed data size */
    uint32_t sealed_size = sgx_calc_sealed_data_size(0, (uint32_t)len);
    if (sealed_size == UINT32_MAX) {
        return SGX_ERROR_UNEXPECTED;
    }

    if (sealed_len < sealed_size) {
        *actual_sealed_len = sealed_size;
        return SGX_ERROR_INVALID_PARAMETER;
    }

    /* Seal the data using MRENCLAVE-based policy
     * (only THIS enclave can unseal) */
    sgx_status_t ret = sgx_seal_data(
        0, NULL,                          /* No additional authenticated data */
        (uint32_t)len, plaintext,         /* Plaintext to seal */
        sealed_size,                      /* Output buffer size */
        (sgx_sealed_data_t *)sealed_data  /* Output sealed blob */
    );

    if (ret == SGX_SUCCESS) {
        *actual_sealed_len = sealed_size;
        ocall_print("[Enclave] Data sealed successfully.");
    }

    return ret;
}

/* ============================================================
 * ECALL: ecall_unseal_data
 * Unseal previously sealed data.
 * ============================================================ */
sgx_status_t ecall_unseal_data(
    const uint8_t *sealed_data,
    size_t sealed_len,
    uint8_t *plaintext,
    size_t plain_len,
    size_t *actual_plain_len)
{
    uint32_t decrypted_len = (uint32_t)plain_len;

    sgx_status_t ret = sgx_unseal_data(
        (const sgx_sealed_data_t *)sealed_data,
        NULL, NULL,                /* No additional authenticated data */
        plaintext, &decrypted_len  /* Output plaintext */
    );

    if (ret == SGX_SUCCESS) {
        *actual_plain_len = decrypted_len;
        ocall_print("[Enclave] Data unsealed successfully.");
    }

    return ret;
}
